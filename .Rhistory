}
}
X
source('~/Dropbox/ProximalAlgorithm/AlphaNorm/R/functions.R', echo=TRUE)
cv.alphanorm(x,y)
source('~/Dropbox/ProximalAlgorithm/AlphaNorm/R/functions.R', echo=TRUE)
cv.alphanorm(x,y)
load_all()
getwd()
library("devtools", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
library("roxygen2", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
load_all()
load_all()
source('~/Dropbox/ProximalAlgorithm/AlphaNorm/R/functions.R', echo=TRUE)
load_all()
library(alphanorm)
library(alphanorm)
library(alphanorm)
library(alphanorm)
library(alphanorm)
library(alphanorm)
library(alphanorm)
library(alphanorm)
library(alphanorm)
x<-matrix(rnorm(100*100),100,100)
y<-x[,1:10]%*%rep(1,10)
obj1<-alphanorm(x,y,intercept=FALSE)
predict.alphanorm(obj1)
cv.alphanorm(x,y)
predict(obj1)
predict(obj1)
predict.alphanorm(obj1)
library(alphanorm)
library(alphanorm)
trace(glmnet)
trace(glmnet:glmnet)
trace(glmnet::glmnet)
setClass("alphanorm",
slots=list(x="matrix",y="vector","Lambda"=vector,
q="vector",Coefficients="matrix",Intercept="numeric"))
#' fit a sparse model with alpha-norm regularization
#' @description Fit a alph-norm model with proximal algorithm and coordinat cyclic descent
#' @param x the design matrix
#' @param y the response vector
#' @param lambda a vector of lambda values, default as exp(-10:10)
#' @param q a numerical value for q, 0<q<=1, with default 0.5
#' @param intercept whether the intercept term should be included, TRUE to be included(default), FALSE not to
#' @param tol tolerence of convergence condition
#' @param T number of maximum iterations for each coefficient
#' @param nlambda number of lambda wanted
#' @return An object of S4 class "alphanorm"
#' \item{x}{input design matrix}
#' \item{y}{input of response vector}
#' \item{Lambda}{input of lambda}
#' \item{q}{input value of q}
#' \item{Coefficient}{matrix coefficients}
#' \item{Intercept}{non-penalized intercept(if intercept=TRUE), otherwise, NULL}
alphanorm = function(x,y,lambda=exp(-10:10),q=0.5,
intercept=TRUE,tol=1e-7,T=500,nlambda=NULL){
if(!is.null(nlambda)){
}
lambda = sort(lambda,decreasing = TRUE)
L = length(lambda)
N = dim(x)[1]
P = dim(x)[2]
y.mean = mean(y)
x.mean = apply(x,2,mean)
Beta.final = matrix(0,P,L)
Inter = NULL
# normalize
if(intercept)
{
y = y - mean(y)
x = sweep(x,2,x.mean)
}
x.norm = apply(x,2,function(x) sqrt(sum(x^2)))
x = x/(x.norm+(x.norm==0))
# initialize
z.initial.max = max(abs(crossprod(x,y)))
beta = rep(0,P)
r = y
# convergence condition
Tol = tol*sum(r^2)/2
Time = P*T
b = (2*lambda*(1-q))^(1/(2-q))
h = b+lambda*q*b^(q-1)
for(l in 1:L)
{
cat("Computing: Log(lambda) = ",log(lambda[l]),"\n")
# proximal parameters and iteration initialization
if(z.initial.max > h[l])
{
k = 1
i = 1
J.change.max = Tol*2
J.change = rep(J.change.max,P)
while(k < Time & J.change.max > Tol)
{
# coordinate
if(i > P) i = 1
# coordinate descent
z = sum(x[,i]*r) + beta[i]
tau = alpha_map(b[l],h[l],z,lambda[l],q,beta[i])
r.change = (tau - beta[i])*x[,i]
J.change[i] = sum((2*r - r.change)*r.change)/2 +
lambda[l]*(abs(beta[i])^q-abs(tau)^q)
# update beta, residual, objective function change
r = r - r.change
beta[i] = tau
J.change.max = max(J.change)
# next coordinate
i = i+1
k = k+1
}
if(k == Time)
print("Coordinate descent did not converge. You might want to increase T or decrease tol")
Beta.final[1:P,l] = beta
}
}
Beta.final = Beta.final/(x.norm+(x.norm==0))
if(intercept)
Inter = y.mean - crossprod(x.mean,Beta.final)
alphanorm.obj<-
return(new("alphanorm",x=x,y=y,"Lambda" = lambda,q=q,"Coefficient" = Beta.final,"Intercept" = Inter))
}
x<-matrix(rnorm(100*100),100,100)
y<-x[,1:10]%*%rep(1,10)
obj1<-alphanorm(x,y,intercept=FALSE)
predict.alphanorm(obj1)
cv.alphanorm(x,y)
obj1<-alphanorm(x,y,intercept=FALSE)
setClass(Class="alphanorm",
representation (x="matrix",y="vector","Lambda"=vector,
q="vector",Coefficients="matrix",Intercept="numeric"))
setClass(Class="alphanorm",
slots=list(x="matrix",y="vector","Lambda"=vector,
q="vector",Coefficients="matrix",Intercept="numeric"))
alphanorm<-setClass(Class="alphanorm",
slots=list(x="matrix",y="vector","Lambda"=vector,
q="vector",Coefficients="matrix",Intercept="numeric"))
alphanorm<-setClass(Class="alphanorm",
slots=list(x="matrix",y="vector","Lambda"=vector,
q="vector",Coefficients="matrix",Intercept="numeric"))
alphanorm<-setClass(Class="alphanorm",
slots=c(x="matrix",y="vector","Lambda"=vector,
q="vector",Coefficients="matrix",Intercept="numeric"))
alphanorm<-setClass(Class="alphanorm",
slots=list(x="matrix",y="vector","Lambda"=vector,
q="vector",Coefficients="matrix",Intercept="numeric"))
library(alphanorm)
obj1<-alphanorm(x,y,intercept=FALSE)
x<-matrix(rnorm(100*100),100,100)
y<-x[,1:10]%*%rep(1,10)
obj1<-alphanorm(x,y,intercept=FALSE)
class(obj1)
predict(obj1)
cv(x,y)
cv.alphanorm(x,y)
library(alphanorm)
library(alphanorm)
library(alphanorm)
devtools::load_all(".")
library(alphanorm)
library(alphanorm)
library(alphanorm)
document()
document()
build_vignettes()
use_vignette("alphanorm")
build_vignettes()
library(alphanorm)
library(alphanorm)
build()
library("glmnet", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
x=matrix(rnorm(100*20),100,20)
y=rnorm(100)
g2=sample(1:2,100,replace=TRUE)
g4=sample(1:4,100,replace=TRUE)
fit1=glmnet(x,y)
plot(fit1)
plot(obj1$Lambda,obj1$Coefficient)
dim(obj1$Coefficient)
matplot(obj1$Lambda,obj1$Coefficient)
matplot(obj1$Lambda,t(obj1$Coefficient))
matplot(log(obj1$Lambda),t(obj1$Coefficient),type="l")
obj1<-alphanorm(x,y,intercept=FALSE)
matplot(log(obj1$Lambda),t(obj1$Coefficient),type="l")
alphanorm.obj<-alphanorm(x,y,intercept=FALSE)
matplot(log(obj1$Lambda),t(obj1$Coefficient),type="l")
matplot(log(obj1$Lambda),t(obj1$Coefficient),type="l")
legend("topright",legend=colnames(obj1$x))
colnames(obj1$x)
obj1$x
colnames(obj1$x)
dim(obj1$x)
legend("topright",legend=1:20)
legend("topright",legend=1:20,col=1:20,lty=1:20)
matplot(log(obj1$Lambda),t(obj1$Coefficient),type="l")
legend("topright",legend=1:20,col=1:20,lty=1:20)
matplot(log(obj1$Lambda),t(obj1$Coefficient),type="l")
legend("topright",legend=1:20,col=1:6,lty=1:5)
library(alphanorm)
library(alphanorm)
library(alphanorm)
library(alphanorm)
x<-matrix(rnorm(100*100),100,100)
# Only the first 10 are true predictors
y<-x[,1:10]%*%rep(1,10)
# Build a alpha-norm model
alphanorm.obj<-alphanorm(x,y,intercept=FALSE)
# Get fitted values
predict(alphanorm.obj)
# Cross-validation to choose q and lambda
cv.alphanorm(x,y,intercept=FALSE)
x<-matrix(rnorm(100*100),100,100)
y<-x[,1:10]%*%rep(1,10)
alphanorm.obj<-alphanorm(x,y,intercept=FALSE)
predict(obj1)
cv.alphanorm(x,y)
coef(obj1)
detach("package:glmnet", unload=TRUE)
library(alphanorm)
coef(obj1)
obj1
coef.alphanorm(obj1)
library(alphanorm)
library(alphanorm)
coef.alphanorm(obj1)
coef(obj1)
dim(obj1$Coefficient)
library(alphanorm)
x<-matrix(rnorm(100*100),100,100)
# Only the first 10 are true predictors
y<-x[,1:10]%*%rep(1,10)
# Build a alpha-norm model
alphanorm.obj<-alphanorm(x,y,intercept=FALSE)
# Get coefficients
coef(alphanorm.obj)
# Get fitted values
predict(alphanorm.obj)
# Cross-validation to choose q and lambda
cv.alphanorm(x,y,intercept=FALSE)
library(alphanorm)
source('~/Dropbox/ProximalAlgorithm/AlphaNorm/R/functions.R', echo=TRUE)
library(alphanorm)
x<-matrix(rnorm(100*100),100,100)
# Only the first 10 are true predictors
y<-x[,1:10]%*%rep(1,10)
# Build a alpha-norm model
alphanorm.obj<-alphanorm(x,y,intercept=FALSE)
# Get coefficients
coef(alphanorm.obj)
# Get fitted values
predict(alphanorm.obj)
# Cross-validation to choose q and lambda
cv.alphanorm(x,y,intercept=FALSE)
library(alphanorm)
x<-matrix(rnorm(100*100),100,100)
# Only the first 10 are true predictors
y<-x[,1:10]%*%rep(1,10)
# Build a alpha-norm model
alphanorm.obj<-alphanorm(x,y,intercept=FALSE)
# Get coefficients
coef(alphanorm.obj)
# Get fitted values
predict(alphanorm.obj)
# Cross-validation to choose q and lambda
cv.alphanorm(x,y,intercept=FALSE)
library(alphanorm)
x<-matrix(rnorm(100*100),100,100)
# Only the first 10 are true predictors
y<-x[,1:10]%*%rep(1,10)
# Build a alpha-norm model
alphanorm.obj<-alphanorm(x,y,intercept=FALSE)
# Get coefficients
coef(alphanorm.obj)
# Get fitted values
predict(alphanorm.obj)
# Cross-validation to choose q and lambda
cv.alphanorm(x,y,intercept=FALSE)
library(alphanorm)
x<-matrix(rnorm(100*100),100,100)
# Only the first 10 are true predictors
y<-x[,1:10]%*%rep(1,10)
# Build a alpha-norm model
alphanorm.obj<-alphanorm(x,y,intercept=FALSE)
# Get coefficients
coef(alphanorm.obj)
# Get fitted values
predict(alphanorm.obj)
# Cross-validation to choose q and lambda
cv.alphanorm(x,y,intercept=FALSE)
library(alphanorm)
x<-matrix(rnorm(100*100),100,100)
# Only the first 10 are true predictors
y<-x[,1:10]%*%rep(1,10)
# Build a alpha-norm model
alphanorm.obj<-alphanorm(x,y,intercept=FALSE)
# Get coefficients
coef(alphanorm.obj)
# Get fitted values
predict(alphanorm.obj)
# Cross-validation to choose q and lambda
cv.alphanorm(x,y,intercept=FALSE)
dim(X)
tmp_rmse<-apply(tmp_beta,2,function(x) sqrt(mean((Ynew-Xnew%*%x)^2)))
tmp_beta<-tmp_tune$Coeffificient
library(alphanorm)
cv.alphanorm(x,y,intercept=FALSE)
dim(alphanorm.obj$Coefficient)
cv.alphanorm<-function(x,y,lambda_Tune=exp(-10:10),q_Tune=c(0.1,0.5,0.9),
intercept=TRUE,nfolds=5,tol=1e-7,T=500){
#Here we use mse as the measure for CV
numTrain<-length(y)
alphaNorm_mse<-array(NA,dim=c(length(q_Tune),length(lambda_Tune),nfolds))
CVsample <- sample(1:numTrain,numTrain)
CVcutoff <- round(seq(0, numTrain, length.out = nfolds + 1))
for(j in 1:nfolds){
newdata <- CVsample[(CVcutoff[j] + 1):CVcutoff[j + 1]]
size <- length(newdata)
X <- as.matrix(x[-newdata,])
Y <- y[-newdata]
Xnew <- x[newdata,]
Ynew <- y[newdata]
if(intercept){
Xnew<- cbind(1,Xnew)
}
for(k in 1:length(q_Tune)){
tmp_tune<-alphanorm(X,Y,lambda=lambda_Tune,q=q_Tune[k],intercept)
if(intercept){
tmp_beta<-rbind(tmp_tune$Intercept,tmp_tune$Coefficient)
}else{
tmp_beta<-tmp_tune$Coeffificient
}
print(dim(tmp_beta))
tmp_mse<-apply(tmp_beta,2,function(x) mean((Ynew-Xnew%*%x)^2))
alphaNorm_mse[k,,j]<-tmp_mse
}
}
alphaNorm_cve <- apply(alphaNorm_mse, c(1,2), mean)
alphaNorm_best <- which(alphaNorm_cve == min(alphaNorm_cve),arr.ind=TRUE)
best_lambda<- lambda_Tune[alphaNorm_best[2]]
best_q <- q_Tune[alphaNorm_best[1]]
cv.alphanorm.obj<-list(lambda=lambda_Tune,q=q_Tune,lambda.min=best_lambda,q.min=best_q,cvm=alphaNorm_cve)
class(cv.alphanorm.obj)<-"cv.alphanorm"
return(cv.alphanorm.obj)
}
cv.alphanorm(x,y,intercept=FALSE)
library(alphanorm)
cv.alphanorm(x,y,intercept=FALSE)
plot(alphanorm.obj)
#' plot coefficient for a "alphanorm"
#' @description Produce a coefficient profile plot of the coefficient paths for a fitted "alphanorm" object
#' @param alphanorm.obj fitted "alphanorm" model
#' @param xvar what is on the X-axis. "norm" plots against the $L_q$-norm of the coefficients, "lambda" against the log-lambda sequence
#' @param legend whether legend should be plotted
#' @seealso alphanorm,and predict methods
#' @export
plot.alphanorm<-function(alphanorm.obj,xvar=c("lambda"),legend=FALSE){
if(xvar=="norm"){
x<-apply(alphanorm.obj$Coefficient,2,function(x) sum(abs(x)^alphanorm.obj$q))
matplot(x,t(alphanorm.obj$Coefficient),type="l",xlab="Lq-norm",y="Coefficients")
}else if(xnorm=="lambda"){
x<-log(alphanorm.obj$Lambda)
matplot(x,t(alphanorm.obj$Coefficient),type="l",xlab="log-lambda",y="Coefficients")
}else{
stop("X-axis can only be norm or lambda")
}
if(label & xvar=="norm"){
if(is.null(colnames(alphanorm.obj$x))){
legend("topleft",legend=1:dim(alphanorm.obj$x)[2],col=1:6,lty=1:5)
}else{
legend("topleft",legend=colnames(alphanorm.obj$x),col=1:6,lty=1:5)
}
}else{
if(is.null(colnames(alphanorm.obj$x))){
legend("topright",legend=1:dim(alphanorm.obj$x)[2],col=1:6,lty=1:5)
}else{
legend("topright",legend=colnames(alphanorm.obj$x),col=1:6,lty=1:5)
}
}
}
plot.alphanorm(alphanorm.obj)
plot.alphanorm<-function(alphanorm.obj,xvar=c("lambda"),legend=FALSE){
if(xvar=="norm"){
x<-apply(alphanorm.obj$Coefficient,2,function(x) sum(abs(x)^alphanorm.obj$q))
matplot(x,t(alphanorm.obj$Coefficient),type="l",xlab="Lq-norm",y="Coefficients")
}else if(xvar=="lambda"){
x<-log(alphanorm.obj$Lambda)
matplot(x,t(alphanorm.obj$Coefficient),type="l",xlab="log-lambda",y="Coefficients")
}else{
stop("X-axis can only be norm or lambda")
}
if(label & xvar=="norm"){
if(is.null(colnames(alphanorm.obj$x))){
legend("topleft",legend=1:dim(alphanorm.obj$x)[2],col=1:6,lty=1:5)
}else{
legend("topleft",legend=colnames(alphanorm.obj$x),col=1:6,lty=1:5)
}
}else{
if(is.null(colnames(alphanorm.obj$x))){
legend("topright",legend=1:dim(alphanorm.obj$x)[2],col=1:6,lty=1:5)
}else{
legend("topright",legend=colnames(alphanorm.obj$x),col=1:6,lty=1:5)
}
}
}
plot.alphanorm(alphanorm.obj)
x<-log(alphanorm.obj$Lambda)
matplot(x,t(alphanorm.obj$Coefficient),type="l",xlab="log-lambda",y="Coefficients")
dim(alphanorm.obj$Coefficient)
x
length(x)
matplot(x,alphanorm.obj$Coefficient,type="l",xlab="log-lambda",y="Coefficients")
matplot(x=x,y=alphanorm.obj$Coefficient,type="l",xlab="log-lambda",y="Coefficients")
matplot(x=x,y=t(alphanorm.obj$Coefficient),type="l",xlab="log-lambda",y="Coefficients")
alphanorm.obj$Coefficient
dim(alphanorm.obj$Coefficient)
matplot(x,t(alphanorm.obj$Coefficient),type="l",xlab="log-lambda",y="Coefficients")
x<-apply(alphanorm.obj$Coefficient,2,function(x) sum(abs(x)^alphanorm.obj$q))
matplot(x,t(alphanorm.obj$Coefficient),type="l",xlab="Lq-norm",y="Coefficients")
length(X)
length(x)
matplot(x,t(alphanorm.obj$Coefficient),type="l",xlab="Lq-norm",y="Coefficients")
matplot(log(obj1$Lambda),t(obj1$Coefficient),type="l")
obj1<-alphanorm(x,y,intercept=FALSE)
x<-matrix(rnorm(100*100),100,100)
y<-x[,1:10]%*%rep(1,10)
obj1<-alphanorm(x,y,intercept=FALSE)
matplot(log(obj1$Lambda),t(obj1$Coefficient),type="l")
length(obj1$Coefficient)
dim(obj1$Coefficient)
dim(obj1$Lambda)
length(obj1$Lambda)
x<-log(alphanorm.obj$Lambda)
alphanorm.obj$Coefficient
matplot(x,t(alphanorm.obj$Coefficient),type="l",xlab="log-lambda",y="Coefficients")
matplot(x,t(alphanorm.obj$Coefficient),type="l",xlab="log-lambda",ylab="Coefficients")
library(alphanorm)
plot(alphanorm.obj)
plot(alphanorm.obj)
Q
library(alphanorm)
library(alphanorm)
plot(alphanorm.obj)
plot(alphanorm.obj,legend=FALSE)
plot(alphanorm.obj,legend=FALSE)
library(alphanorm)
plot(alphanorm.obj,legend=FALSE)
plot(alphanorm.obj,xvar="norm",legend=FALSE)
library(alphanorm)
x<-matrix(rnorm(100*100),100,100)
# Only the first 10 are true predictors
y<-x[,1:10]%*%rep(1,10)
# Build a alpha-norm model
alphanorm.obj<-alphanorm(x,y,intercept=FALSE)
# Get coefficients
coef(alphanorm.obj)
# Get fitted values
predict(alphanorm.obj)
# Cross-validation to choose q and lambda
cv.alphanorm(x,y,intercept=FALSE)
# Plot coefficient profile according to log-lambda
plot(alphanorm.obj)
library(alphanorm)
library(alphanorm)
build_vignettes()
build_vignettes()
alpha_map = function(b,h,z,lambda,q,beta)
{
tau = 0
abz = abs(z)
if(abz==h)
{
tau = ifelse(beta==0,0,sign(z)*b)
return(tau)
}
if(abs(z)>h)
{
tau = sign(z)*uniroot(function(x) x+lambda*q*x^(q-1)-abz,
lower = b,
upper = abz)$root
return(tau)
}
return(tau)
}
document()
library(alphanorm)
library(alphanorm)
library(alphanorm)
library(alphanorm)
document()
document()
document()
library(alphanorm)
library(alphanorm)
help(alphanorm)
x=matrix(rnorm(100*20),100,20)
y=rnorm(100)
obj1=alphanorm(x,y)
plot(alphanorm)
plot(alphanorm,xvar="norm")
library(alphanorm)
library(alphanorm)
check(cleanup = FALSE,args = c('--no-examples'),manual = TRUE,path = getwd())
getwd()
check(cleanup = FALSE,manual = TRUE,path = getwd())
system("R CMD Rd2pdf MyRpackage")
system("R CMD Rd2pdf alphanorm")
library(alphanorm)
library(alphanorm)
library(alphanorm)
